/*{
  "type": "action",
  "targets": ["omnifocus"],
  "author": "Henry Gustafson",
  "identifier": "com.github.lizard-heart.omni-focus-start-toggl-timer",
  "version": "1.0",
  "description": "Run this automation when highlighting a task to start a timer in toggl with the task name as the description, project name as project, and any tags attached to the OmniFocus task.",
  "label": "Start Toggl Timer",
  "shortLabel": "Start Timer"
}*/

(() => {
  // add your toggl api token here
  const api_key = "56cfe52d83297ef1f4aac3b4c44e8867";

  const AuthHeader = `Basic ${btoa(`${api_key}:api_token`)}`;

  const buildErrorObject = (r) => ({
    statusCode: r.statusCode,
    data: r.bodyString,
  });


  // this function makes a fetch request to the toggl api
  async function startTimer(timeEntry, workspaceId) {
    const fetchRequest = new URL.FetchRequest();
    // Add ISO 8601 timestamp for start time (current time in UTC)
    const now = new Date().toISOString();
    fetchRequest.bodyData = Data.fromString(
      JSON.stringify({
        ...timeEntry,
        start: now,
        workspace_id: workspaceId,
        duration: -1, // Negative duration indicates a running timer
      })
    );
    fetchRequest.method = 'POST';
    fetchRequest.headers = {
      Authorization: AuthHeader,
      ['Content-Type']: 'application/json',
    };
    fetchRequest.url = URL.fromString(
      `https://api.track.toggl.com/api/v9/workspaces/${workspaceId}/time_entries`
    );
    const r = await fetchRequest.fetch();

    if (r.statusCode !== 200) {
      throw buildErrorObject(r);
    }

    return JSON.parse(r.bodyString);
  }

  async function createTogglProject(name, workspaceId) {
    const fetchRequest = new URL.FetchRequest();
    fetchRequest.bodyData = Data.fromString(JSON.stringify({
      name,
      active: true
    }));
    fetchRequest.method = 'POST';
    fetchRequest.headers = {
      Authorization: AuthHeader,
      ['Content-Type']: 'application/json',
    };
    fetchRequest.url = URL.fromString(
      `https://api.track.toggl.com/api/v9/workspaces/${workspaceId}/projects`
    );
    const r = await fetchRequest.fetch();

    if (r.statusCode !== 200) {
      throw buildErrorObject(r);
    }

    return JSON.parse(r.bodyString);
  }

  async function activateTogglProject(projectId, workspaceId) {
    const fetchRequest = new URL.FetchRequest();
    fetchRequest.bodyData = Data.fromString(JSON.stringify({
      active: true
    }));
    fetchRequest.method = 'PUT';
    fetchRequest.headers = {
      Authorization: AuthHeader,
      ['Content-Type']: 'application/json',
    };
    fetchRequest.url = URL.fromString(
      `https://api.track.toggl.com/api/v9/workspaces/${workspaceId}/projects/${projectId}`
    );
    const r = await fetchRequest.fetch();

    if (r.statusCode !== 200) {
      throw buildErrorObject(r);
    }

    return JSON.parse(r.bodyString);
  }

  async function getCurrentTimeEntry() {
    const fetchRequest = new URL.FetchRequest();
    fetchRequest.method = 'GET';
    fetchRequest.headers = {
      Authorization: AuthHeader,
      ['Content-Type']: 'application/json',
    };
    fetchRequest.url = URL.fromString(
      `https://api.track.toggl.com/api/v9/me/time_entries/current`
    );
    const r = await fetchRequest.fetch();

    if (r.statusCode === 200) {
      const body = JSON.parse(r.bodyString);
      return body || null;
    }

    return null;
  }

  async function stopTimeEntry(timeEntryId, workspaceId) {
    const fetchRequest = new URL.FetchRequest();
    fetchRequest.method = 'PATCH';
    fetchRequest.headers = {
      Authorization: AuthHeader,
      ['Content-Type']: 'application/json',
    };
    fetchRequest.url = URL.fromString(
      `https://api.track.toggl.com/api/v9/workspaces/${workspaceId}/time_entries/${timeEntryId}/stop`
    );
    const r = await fetchRequest.fetch();

    if (r.statusCode !== 200) {
      throw buildErrorObject(r);
    }

    return JSON.parse(r.bodyString);
  }

  async function getTogglData() {
    const fetchRequest = new URL.FetchRequest();
    fetchRequest.method = 'GET';
    fetchRequest.headers = {
      Authorization: AuthHeader,
      ['Content-Type']: 'application/json',
    };
    fetchRequest.url = URL.fromString(
      `https://api.track.toggl.com/api/v9/me?with_related_data=true`
    );
    const r = await fetchRequest.fetch();
    console.log(r)


    if (r.statusCode !== 200) {
      throw buildErrorObject(r);
    }

    return JSON.parse(r.bodyString);
  }

  async function log(message, title = 'Log') {
    const a = new Alert(title, message);
    a.addOption('OK');
    await a.show();
  }

  var action = new PlugIn.Action(async function (selection) {
    try {

      let projects = [];
      let workspaceId = null;

      try {
        const userData = await getTogglData();
        projects = userData.projects || [];
        workspaceId = userData.default_workspace_id;

        if (!workspaceId) {
          await log('No workspace found. Please check your Toggl account.', 'Error');
          return;
        }
      } catch (e) {
        await log(
          'An error occurred getting projects',
          'See console for more info'
        );
        console.log(e);
        return;
      }

      var isProject = false
      if (selection.tasks.length == 0) {
        isProject = true
      }

      if (isProject == true) {
        console.log("true")
        let taskName = "";
        let projectName = "";
        let projectNameWhole = selection.projects[0].name
        if (projectNameWhole.includes(":")){
          projectName = projectNameWhole.split(": ")[0]
          taskName = projectNameWhole.split(": ")[1]
        } else {
          projectName = projectNameWhole
          // taskName = task.name
        }
        console.log(projectNameWhole)
        let task = selection.projects[0]
        const taskTags = task.tags.map((t) => t.name);
        const TogglTags = []
        for (var i = 0; i < taskTags.length; i++) {
              if (String(taskTags[i]).includes("Toggl")) {
                  TogglTags.push(taskTags[i].slice(5))
              }
          }
        console.log(TogglTags)

        const togglProject = projects.find(
          (p) => p.name.trim().toLowerCase() === projectName.trim().toLowerCase()
        );

        let pid;
        if (!projectName) {
          pid = null;
        } else if (!togglProject) {
          console.log(`creating project in toggl called ${projectName} because it was not found`);
          try {
            const r = await createTogglProject(projectName, workspaceId);
            console.log(`project created with id: ${r.id}`);
            pid = r.id;
          } catch (e) {
            console.log(`error creating project ${projectName}`);
            console.log(e);
          }
        } else {
          pid = togglProject.id;
          // Check if project is archived and activate it if needed
          if (!togglProject.active) {
            console.log(`project ${projectName} is archived, activating it`);
            try {
              await activateTogglProject(pid, workspaceId);
              console.log(`project ${projectName} activated successfully`);
            } catch (e) {
              console.log(`error activating project ${projectName}`);
              console.log(e);
            }
          }
        }

        // Check if there's already a running timer for this task
        try {
          const currentEntry = await getCurrentTimeEntry();

          if (currentEntry && currentEntry.description === taskName) {
            // Stop the running timer
            await stopTimeEntry(currentEntry.id, workspaceId);
            console.log('Timer stopped for:', taskName);
            await log(`Timer stopped for "${taskName}"`, 'Timer Stopped');
            return;
          }
        } catch (e) {
          console.log('Error checking current timer:', e);
        }

        try {
          const r = await startTimer({
            description: taskName,
            created_with: 'OmniFocus-automation',
            tags: TogglTags,
            project_id: pid,
          }, workspaceId);
          console.log('Timer started successfully', JSON.stringify(r));
          await log(`Timer started for "${taskName}"`, 'Timer Started');
        } catch (e) {
          await log('An error occurred', 'See the console for more info');
          console.log(JSON.stringify(e, null, 2));
        }
      } else {
        const task = selection.tasks[0]

        let taskName = "";
        let projectNameWhole = task.containingProject && task.containingProject.name;
        let projectName = ""
        if (projectNameWhole && projectNameWhole.includes(":")){
          projectName = projectNameWhole.split(": ")[0]
          taskName = projectNameWhole.split(": ")[1] + ": " + task.name
        } else {
          projectName = projectNameWhole
          taskName = task.name
        }



        const togglProject = projects.find(
          (p) => p.name.trim().toLowerCase() === projectName.trim().toLowerCase()
        );



        let pid;
        if (!projectName) {
          pid = null;
        } else if (!togglProject) {
          console.log(`creating project in toggl called ${projectName} because it was not found`);
          try {
            const r = await createTogglProject(projectName, workspaceId);
            console.log(`project created with id: ${r.id}`);
            pid = r.id;
          } catch (e) {
            console.log(`error creating project ${projectName}`);
            console.log(e);
          }
        } else {
          pid = togglProject.id;
          // Check if project is archived and activate it if needed
          if (!togglProject.active) {
            console.log(`project ${projectName} is archived, activating it`);
            try {
              await activateTogglProject(pid, workspaceId);
              console.log(`project ${projectName} activated successfully`);
            } catch (e) {
              console.log(`error activating project ${projectName}`);
              console.log(e);
            }
          }
        }
        console.log('pid is: ', pid);

        const taskTags = task.tags.map((t) => t.name);

        const TogglTags = []
        for (var i = 0; i < taskTags.length; i++) {
              if (String(taskTags[i]).includes("Toggl")) {
                  TogglTags.push(taskTags[i].slice(5))
              }
          }
          console.log(TogglTags)

        // Check if there's already a running timer for this task
        try {
          const currentEntry = await getCurrentTimeEntry();

          if (currentEntry && currentEntry.description === taskName) {
            // Stop the running timer
            await stopTimeEntry(currentEntry.id, workspaceId);
            console.log('Timer stopped for:', taskName);
            await log(`Timer stopped for "${taskName}"`, 'Timer Stopped');
            return;
          }
        } catch (e) {
          console.log('Error checking current timer:', e);
        }

        try {
          const r = await startTimer({
            description: taskName,
            created_with: 'OmniFocus-automation',
            tags: TogglTags,
            project_id: pid,
          }, workspaceId);
          console.log('Timer started successfully', JSON.stringify(r));
          await log(`Timer started for "${taskName}"`, 'Timer Started');
        } catch (e) {
          await log('An error occurred', 'See the console for more info');
          console.log(JSON.stringify(e, null, 2));
        }

      } //end brace


    } catch (e) {
      await log('An error occurred', 'See console for more info');
      console.log(JSON.stringify(e, null, 2));
    }


  });

  // action.validate = function (selection, sender) {
  //   return selection.tasks.length === 1;
  // };

  // Here I'm using https://github.com/MaxArt2501/base64-js/blob/master/base64.js
  function btoa(stringParam) {
    const b64 =
      'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';
    const string = String(stringParam);
    var bitmap,
      a,
      b,
      c,
      result = '',
      i = 0,
      rest = string.length % 3;

    for (; i < string.length; ) {
      if (
        (a = string.charCodeAt(i++)) > 255 ||
        (b = string.charCodeAt(i++)) > 255 ||
        (c = string.charCodeAt(i++)) > 255
      ) {
        throw "Error";
      }

      bitmap = (a << 16) | (b << 8) | c;
      result +=
        b64.charAt((bitmap >> 18) & 63) +
        b64.charAt((bitmap >> 12) & 63) +
        b64.charAt((bitmap >> 6) & 63) +
        b64.charAt(bitmap & 63);
    }
    return rest ? result.slice(0, rest - 3) + '==='.substring(rest) : result;
  }

  return action;
})();
